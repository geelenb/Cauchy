<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Visualizing closed loop poles</title>
    <style>
        body {
            margin: 0;
        }

        body > h1 {
            text-align: center;
            grid-area: top / left / 2 / right;
        }

        body > div.column {
            text-align: center;
            width: 31.33vw;
            float: left;
            margin: 0 1vw;
        }

        body > div#credits {
            clear: both;
            width: 100%;
        }

        canvas {
            box-shadow: grey 2px 2px 4px;
            border-radius: 6px;
        }

        table.equationtable {
            border-collapse: collapse;
        }

        table.equationtable td.counter {
            border-bottom: 1px solid black;
        }

        h1, h2, h3 {
            font-family: Futura, Helvetica, "Helvetica Neue", sans-serif;
        }

        p, div {
            font-family: Optima, sans-serif;
        }
    </style>

    <script src="math.min.js"></script>
    <script src="fraction.min.js"></script>
    <script src="complex.min.js"></script>
    <script src="polynomial.js"></script>
</head>
<body>
<h1>Visualizing closed loop poles</h1>

<div class="column">
    <h3>s-plane</h3>
    <canvas id="input_canvas"></canvas>
    <p>
        This is the input screen, showing the poles and zeros of the function G(s).
        Add or remove zeros and poles to G by left- and right-clicking.
    </p>
    <div style="width: 11ch; display: inline-block; text-align: left;">
        K = 10<sup><span id="k_pow_span"></span></sup>
    </div>
    <br>
    <input id="krange" max="2" min="-2" step='.01' style="width: 250px; min-width: 50%; max-width: 100%;" type="range">
    <p id="G_equation"></p>
</div>

<div class="column">
    <h3>w-plane</h3>
    <canvas id="output_canvas"></canvas>
    <p>
        The blue point s is mapped to the w-plane by the function KG(s).
        Similarly, a contour is mapped to a plot.
        Note that you can scale this plot by modifying K.
    </p>
    <p>
        Use the following buttons to specify the interaction mode:
    </p>
    <p style="text-align: left">
        <input checked id="radiobutton_zero" name="interactiontype" onclick="set_mode('zero')" type="radio">
        <label for="radiobutton_zero">Orbit a zero</label><br>
        <input id="radiobutton_pole" name="interactiontype" onclick="set_mode('pole')" type="radio">
        <label for="radiobutton_pole">Orbit a pole</label><br>
        <input id="radiobutton_nyquist" name="interactiontype" onclick="set_mode('nyquist')" type="radio">
        <label for="radiobutton_nyquist">Nyquist contour</label><br>
        <input id="radiobutton_interactive" name="interactiontype" onclick="set_mode('interactive')"
               type="radio">
        <label for="radiobutton_interactive">Interactive</label><br>
    </p>
</div>
<!--
<div class="column">
    <h3>Bode Plot</h3>
    <canvas id="bode_canvas"></canvas>
</div>
-->
<div class="column">
    <h3>Root locus</h3>
    <canvas id="rlocus_canvas"></canvas>
    <p>
        Shows the zeros of 1+KG(s) = 0 for every positive K.
        <br>
        <button onclick="increase_rl_range()">Enlarge range of Ks</button>
        <button onclick="increase_rl_resolution()">Increase resolution of Ks</button>
    </p>
</div>

<div id="credits" style="text-align: center">
    Made by Bram Geelen @ ESAT - STADIUS.
    <br>
    Source code at <a href="https://gitlab.esat.kuleuven.be/Bram.Geelen/cauchy" target="_blank">gitlab.esat.kuleuven.be/Bram.Geelen/cauchy</a>
    <br>
    Uses
    <a href="https://mathjs.org/" target="_blank">Math.js</a>,
    <a href="https://github.com/infusion/Fraction.js/" target="_blank">fraction.js</a>
    <a href="https://github.com/infusion/complex.js/" target="_blank">complex.js</a> and
    <a href="https://github.com/infusion/polynomial.js/" target="_blank">polynomial.js</a> .
</div>

<script>
    Polynomial.setField('C');

    let scale = 75;

    const in_ctx = document.getElementById('input_canvas').getContext('2d');
    const out_ctx = document.getElementById('output_canvas').getContext('2d');
    const rl_ctx = document.getElementById('rlocus_canvas').getContext('2d');
    const krange = document.getElementById('krange');
    const k_pow_span = document.getElementById('k_pow_span');

    let contour = [];
    let plot = [];
    let points_start_index = 30;

    const zeros = [Complex(-2)];
    const poles = [Complex(-3, -2), Complex(-3, 2)];
    let K = 1;

    function f(s) {
        s = Complex(s);
        const counter = zeros.map(z => s.sub(z)).reduce(mul, Complex.ONE);
        const denominator = poles.map(p => s.sub(p)).reduce(mul, Complex.ONE);
        return counter.mul(K).div(denominator);
    }

    function add_drag(ctx) {
        ctx.canvas.addEventListener('mousedown', () => ctx.canvas.isdragging = false);

        ctx.canvas.addEventListener('mousemove', (event) => {
            if (event.buttons) {
                console.log(ctx === in_ctx,  ctx === rl_ctx);
                if (ctx === in_ctx || ctx === rl_ctx) {
                    in_ctx.translate(event.movementX, event.movementY);
                    rl_ctx.translate(event.movementX, event.movementY);
                    requestAnimationFrame(redraw_in);
                    requestAnimationFrame(redraw_rl);

                } else {
                    // (ctx === out_ctx)
                    ctx.translate(event.movementX, event.movementY);
                    requestAnimationFrame(redraw_out);
                }

                ctx.canvas.isdragging = true;
            }
        });
    }

    add_drag(in_ctx);
    add_drag(out_ctx);
    add_drag(rl_ctx);

    function add_axes(ctx) {
        const axes_length = 10;

        ctx.save();
        ctx.font = '14px serif';

        ctx.strokestyle = 'black';
        ctx.lineWidth = 1;

        ctx.beginPath();
        ctx.moveTo(-1000 * scale, 0);
        ctx.lineTo(+1000 * scale, 0);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, -1000);
        ctx.lineTo(0, +1000);
        ctx.stroke();

        // labels
        for (let i = -axes_length; i <= axes_length; i++) {
            if (i === 0) {
                continue;
            }

            // x axis
            ctx.beginPath();
            ctx.moveTo(i * scale, 0);
            ctx.lineTo(i * scale, 6);
            ctx.stroke();

            ctx.textAlign = 'center';
            ctx.textBaseline = 'hanging';
            ctx.fillText(`${i}`, i * scale, 10);

            // y axis
            ctx.beginPath();
            ctx.moveTo(0, i * scale);
            ctx.lineTo(-6, i * scale);
            ctx.stroke();

            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${i}j`, -10, -i * scale);
        }

        ctx.textAlign = 'right';
        ctx.textBaseline = 'hanging';
        ctx.fillText('0', -10, 10);

        ctx.restore();
    }

    function headpoint(points) {
        if (mode === 'interactive') {
            return points[points.length - 1];
        } else {
            return points[(points_start_index - 1 + points.length) % points.length];
        }
    }

    function draw_points(ctx, points) {
        if (points.length === 0) {
            return;
        }

        if (window.mode === 'interactive') {
            const n = points.length;
            // only plot last sqrt (length) items of points
            points = points.slice(Math.floor(n - Math.sqrt(n)));
        }

        points = points.map(s => [s.re * scale, -s.im * scale]);

        ctx.save();
        ctx.beginPath();
        ctx.moveTo(...(points[0]));

        ctx.strokeStyle = 'cyan';
        points.forEach(point => {
            ctx.lineTo(...point);
        });

        ctx.stroke();

        const point = points[points_start_index % points.length];
        ctx.fillStyle = ctx.strokeStyle;
        ctx.beginPath();
        ctx.arc(point[0], point[1], 3, 0, 2 * Math.PI);
        ctx.fill();

        ctx.restore();
    }

    function draw_poles(ctx) {
        const size = 3;
        ctx.save();
        ctx.strokeStyle = 'blue';
        poles.forEach(p => {
            ctx.beginPath();
            ctx.moveTo(p.re * scale - size, -(p.im * scale - size));
            ctx.lineTo(p.re * scale + size, -(p.im * scale + size));
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(p.re * scale - size, -(p.im * scale + size));
            ctx.lineTo(p.re * scale + size, -(p.im * scale - size));
            ctx.stroke();
        });

        ctx.restore();
    }

    function draw_zeros(ctx) {
        const r = 5;
        ctx.save();
        ctx.strokeStyle = 'blue';
        zeros.forEach(p => {
            ctx.beginPath();
            // ctx.moveTo(p.re * scale, -(p.im * scale));
            ctx.arc(p.re * scale, -(p.im * scale), r, 0, Math.PI * 2);
            ctx.stroke();
        });

        ctx.restore();
    }

    const mul = (a, b) => a.mul(b);
    const div = (a, b) => a.div(b);

    function redraw_in() {
        const draw_in_phasors = () => {
            if (contour.length === 0) {
                return;
            }

            const s = headpoint(contour);

            in_ctx.save();
            const r = 10;
            in_ctx.strokeStyle = 'lightgrey';
            poles.concat(zeros).forEach(c => {
                in_ctx.beginPath();
                in_ctx.moveTo(s.re * scale, -s.im * scale);
                in_ctx.lineTo(c.re * scale, -c.im * scale);
                in_ctx.stroke();
            });

            in_ctx.strokeStyle = 'red';
            poles.forEach(p => {
                in_ctx.beginPath();
                in_ctx.arc(p.re * scale, -p.im * scale, r, -s.sub(p).arg(), 0);
                in_ctx.stroke();
            });

            in_ctx.strokeStyle = 'darkgreen';
            zeros.forEach(z => {
                in_ctx.beginPath();
                in_ctx.arc(z.re * scale, -z.im * scale, r, -s.sub(z).arg(), 0);
                in_ctx.stroke();
            });

            in_ctx.restore()
        };

        in_ctx.clearRect(-1000, -1000, 2000, 2000);
        add_axes(in_ctx);

        draw_points(in_ctx, contour);

        draw_in_phasors();

        draw_poles(in_ctx);
        draw_zeros(in_ctx);
    }

    function redraw_out() {
        const draw_out_phasors = () => {
            if (contour.length === 0) {
                return;
            }
            let sum_phase = 0;
            let r = 10;

            const s = headpoint(contour);
            out_ctx.save();

            out_ctx.strokeStyle = 'lightgrey';
            const fs = headpoint(plot);

            out_ctx.beginPath();
            out_ctx.moveTo(0, 0);
            out_ctx.lineTo(fs.re * scale, -fs.im * scale);
            out_ctx.stroke();

            out_ctx.strokeStyle = 'darkgreen';

            zeros.forEach(z => {
                out_ctx.beginPath();
                let phase = -s.sub(z).arg();
                out_ctx.arc(0, 0, r, phase + sum_phase, sum_phase);
                sum_phase += phase;
                r += 5;
                out_ctx.stroke();
            });

            out_ctx.strokeStyle = 'red';
            poles.forEach(p => {
                out_ctx.beginPath();
                let phase = s.sub(p).arg();
                out_ctx.arc(0, 0, r, sum_phase, phase + sum_phase);
                sum_phase += phase;
                r += 5;
                out_ctx.stroke();
            });

            out_ctx.restore()
        };

        out_ctx.clearRect(-1000, -1000, 2000, 2000);
        add_axes(out_ctx);

        draw_points(out_ctx, plot);

        draw_out_phasors();
    }

    function complex_rand() {
        return Complex(math.random() - .5, math.random() - .5);
    }

    let n_ks = 3000;
    let max_exponent = 2;

    function increase_rl_resolution() {
        n_ks *= 2;
        force_recalculate_root_lines();
        redraw_rl();
    }

    function increase_rl_range() {
        max_exponent += 1;
        force_recalculate_root_lines();
        redraw_rl();
    }

    let last_calculated_poly = '';
    let root_lines = [];

    function recalculate_root_lines() {
        // 1 + KP = 0
        // P = counter / denominator
        // denominator + K counter = 0

        const counter = Polynomial.fromRoots(zeros);
        const denominator = Polynomial.fromRoots(poles);

        const poly_1 = counter.add(denominator); // K = 1

        if (poly_1.toString() === last_calculated_poly) {
            console.log('using cached root lines');
            return;
        }
        console.log('calculating root lines');
        last_calculated_poly = poly_1.toString();

        force_recalculate_root_lines();
    }

    function force_recalculate_root_lines() {
        const counter = Polynomial.fromRoots(zeros);
        const denominator = Polynomial.fromRoots(poles);

        const ks = Array(n_ks).fill(0).map((_, i) =>
            Math.pow(10, (i / (n_ks - 1) - .5) * 2 * max_exponent));

        const calculate_roots = (poly, est) => {
            let roots = [];
            poly = poly.monic();
            while (poly.coeff[0].abs() === 0) {
                roots.push(Complex.ZERO);
                poly = poly.div('x').monic();
            }

            if (est === undefined) {
                est = Array(poly.degree()).fill().map(complex_rand)
            }

            poly.complexRoots(est).root.forEach(root => roots.push(root));

            return roots
        };

        const roots_per_K = [];
        roots_per_K.push(calculate_roots(counter.mul(ks[0]).add(denominator)));

        for (let i = 1; i < n_ks; i++) {
            let estimated_roots = roots_per_K[i - 1];
            roots_per_K.push(calculate_roots(
                counter.mul(ks[i]).add(denominator),
                estimated_roots
            ));
        }

        root_lines = roots_per_K[0].map(() => []);
        roots_per_K.forEach(roots =>
            roots.forEach((root, i) =>
                root_lines[i].push(root)));
    }

    function draw_root_lines() {
        rl_ctx.save();
        rl_ctx.strokeStyle = 'blue';
        rl_ctx.lineWidth = 2;

        root_lines.forEach(root_line => {
            const points = root_line.map(s => s.mul(scale).toVector());

            if (true) {
                // draw line
                rl_ctx.beginPath();
                rl_ctx.moveTo(...(points[0]));
                points.forEach(point => {
                    rl_ctx.lineTo(...point);
                });

                rl_ctx.stroke();
            } else {
                // Draw points
                points.forEach(point => {
                    rl_ctx.fillStyle = rl_ctx.strokeStyle;
                    rl_ctx.beginPath();
                    rl_ctx.arc(point[0], point[1], 2, 0, 2 * Math.PI);
                    rl_ctx.fill();
                });
            }
        });
        rl_ctx.restore();
    }

    function draw_closed_loop_poles() {
        console.log('calculating closed loop poles for a single K...')
        // 1 + KP = 0
        // P = counter / denominator
        // denominator + K counter = 0

        const counter = Polynomial.fromRoots(zeros);
        const denominator = Polynomial.fromRoots(poles);

        const poly = counter.mul(K).add(denominator).monic();

        let est = Array(poly.degree()).fill().map(complex_rand);
        const found_roots = poly.complexRoots(est).root;

        found_roots.forEach(root => {
            let [x, y] = root.mul(scale).toVector();

            rl_ctx.save();
            // rl_ctx.strokeStyle = 'black';
            rl_ctx.lineWidth = 2;

            let d = .1 * scale;

            rl_ctx.beginPath();
            rl_ctx.moveTo(x - d, y);
            rl_ctx.lineTo(x + d, y);
            rl_ctx.stroke();

            rl_ctx.beginPath();
            rl_ctx.moveTo(x, y - d);
            rl_ctx.lineTo(x, y + d);
            rl_ctx.stroke();

            rl_ctx.restore();
        });

    }

    function redraw_rl() {
        rl_ctx.clearRect(-1000, -1000, 2000, 2000);
        add_axes(rl_ctx);

        draw_root_lines();
        draw_closed_loop_poles();

        draw_poles(rl_ctx);
        draw_zeros(rl_ctx);
    }

    function redraw_in_out() {
        redraw_in();
        redraw_out();
    }

    function redraw_all() {
        redraw_in();
        redraw_out();
        redraw_rl();
    }

    function round_complex(c) {
        return Complex(
            round_n(c.re, 1),
            round_n(c.im, 1)
        )
    }

    /**
     * Round to n decimals after point
     * @param x
     * @param n decimals
     * @returns {number}
     */
    function round_n(x, n) {
        let p = Math.pow(10, n);
        return Math.round(x * p) / p
    }

    function coor_for_event(event, ctx) {
        const rect = ctx.canvas.getBoundingClientRect();
        const point_unscaled = (ctx
                .getTransform()
                .inverse()
                .transformPoint({
                    x: event.clientX - rect.left,
                    y: event.clientY - rect.top
                })
        );

        return Complex(
            point_unscaled.x / scale,
            -point_unscaled.y / scale
        )
    }

    function circle_around(p) {
        const n = 1000;
        return [...Array(n).keys()].reverse().map(v => p.add({arg: ((v / n) * 2 * Math.PI), abs: 0.8}));
    }

    function nyquist_contour() {
        const omegas = math.range(-1.57, 1.57, .003).map(x => math.tan(x));
        const omega_js = omegas.map(o => Complex(0, o));
        return omega_js.toArray(); //.push(Complex(1000, 0));
    }

    function start_animation() {
        if (window.mode === 'interactive') {
            return;
        }
        requestAnimationFrame(redraw_in_out);

        points_start_index += 1;
        setTimeout(start_animation, 5);
    }

    function set_mode(new_mode) {
        const was_already_animating = window.mode !== 'interactive';

        window.mode = new_mode;

        if (new_mode === 'interactive') {
            contour = [];
            plot = [];
        } else if (new_mode === 'zero') {
            contour = circle_around(zeros[math.randomInt(zeros.length)]);
            plot = contour.map(f);
        } else if (new_mode === 'pole') {
            contour = circle_around(poles[math.randomInt(poles.length)]);
            plot = contour.map(f);
        } else if (new_mode === 'nyquist') {
            contour = nyquist_contour();
            plot = contour.map(f);
        }

        if (!was_already_animating) {
            start_animation();
        }
    }

    in_ctx.canvas.addEventListener('mousemove', (event) => {
        if (mode === 'interactive') {
            const coor = coor_for_event(event, in_ctx);
            contour.push(coor);
            plot.push(f(coor));

            requestAnimationFrame(redraw_in_out);
        }
    });

    function pole_or_zero_clicked(event) {
        if (in_ctx.canvas.isdragging) {
            return;
        }

        let poles_or_zeros = event.type === 'contextmenu' ? poles : zeros;
        let clicked = coor_for_event(event, in_ctx);

        // remove poles_or_zeros that are close to click
        const pz_to_keep = poles_or_zeros.filter(z => clicked.sub(z).abs() > .2 && clicked.sub(z.conjugate()).abs() > .2);

        if (pz_to_keep.length !== poles_or_zeros.length) {
            // remove the poles_or_zeros in-place:
            poles_or_zeros.splice(0, poles_or_zeros.length, ...pz_to_keep);
        } else {
            // if no poles_or_zeros were removed: add one
            clicked = round_complex(clicked);
            poles_or_zeros.push(clicked);
            if (clicked.im !== 0) {
                poles_or_zeros.push(clicked.conjugate())
            }
        }

        plot = contour.map(f);
        recalculate_root_lines();
        requestAnimationFrame(redraw_all);
        update_G_description();
        event.preventDefault();
    }

    in_ctx.canvas.addEventListener('click', pole_or_zero_clicked);
    in_ctx.canvas.addEventListener('contextmenu', pole_or_zero_clicked);

    function update_K_in_G_description() {
        let K_str = K === 1 ? '' : String(round_n(K, 2));
        Array.from(document.getElementsByClassName('K_val')).forEach(elem => elem.innerText = K_str);
    }

    function update_G_description() {
        const roots_to_html = roots => {
            if (roots.length == 0) {
                return '1';
            }
            const complex_to_str = c => (c.re < 0 || (c.re == 0 && c.im < 0)) ? c.toString() : ('+' + c.toString());
            const complex_to_s_minus = c => Complex.ZERO.equals(c) ? 's' : '(s' + complex_to_str(Complex(0).sub(c)) + ')';
            const add_spacing = s => s.replaceAll('i', 'j').replaceAll('+', '&nbsp+&nbsp').replaceAll('-', '&nbsp-&nbsp');

            // TODO : powers for double roots?

            let html = roots.map(complex_to_s_minus).map(add_spacing).join('&nbsp;');

            if (roots.length == 1) {
                html = html.substr(1, html.length - 2)
            }

            return html
        };

        const roots_to_html_poly = roots => {
            if (roots.length === 0) {
                return '1';
            }
            const poly = Polynomial.fromRoots(roots);
            const coeffs = poly.monic().coeff;

            const s_pow = (pow) => pow === '0' ? '' : pow === '1' ? 's' : `s<sup>${pow}</sup>`;

            return Object.entries(coeffs).reverse().map(([pow, coeff], i) =>
                `${coeff === 1 ? '' : round_n(coeff, 3)}${s_pow(pow)}`
            ).join('&nbsp;+&nbsp;').replaceAll('+&nbsp;-', '-&nbsp;').replaceAll('i', 'j');
        };

        let counter_roots = roots_to_html(zeros);
        let counter_polynomic = roots_to_html_poly(zeros);
        let denominator_roots = roots_to_html(poles);
        let denominator_polynomic = roots_to_html_poly(poles);

        document.getElementById('G_equation').innerHTML = [
            '<table class="equationtable"><tr>',
            '<td rowspan="2">KG(s)</td>',
            '<td rowspan="2" >=&nbsp; <span class="K_val"></span> </td>',
            `<td class="counter">&nbsp;${counter_roots}&nbsp;</td>`,
            '</tr>',
            '<tr>',
            `<td>&nbsp;${denominator_roots}&nbsp;</td>`,
            '</tr>',
            '<tr style="height: 2ch"></tr>',
            '<tr>',
            '<td rowspan="2"></td>',
            '<td rowspan="2">&nbsp;=&nbsp;<span class="K_val"></span> </td>',
            `<td class="counter">&nbsp;${counter_polynomic}&nbsp;</td>`,
            '</tr>',
            '<tr>',
            `<td>&nbsp;${denominator_polynomic}&nbsp;</td>`,
            '</tr>',
            '</table>'
        ].join('');
        update_K_in_G_description();
    }

    function k_changed() {
        K = Math.pow(10, krange.value);
        k_pow_span.innerText = krange.value;

        plot = contour.map(f);
        redraw_rl();
        update_K_in_G_description();
    }

    krange.addEventListener('input', k_changed);

    function layoutchanged() {
        let canvases = document.querySelectorAll('canvas');
        canvases.forEach(canvas => {
            let w = canvas.parentElement.clientWidth;
            canvas.width = w;
            canvas.height = w;
        });

        in_ctx.translate(out_ctx.canvas.height / 1.3, out_ctx.canvas.height / 2);
        out_ctx.translate(out_ctx.canvas.height / 2, out_ctx.canvas.height / 2);
        rl_ctx.translate(out_ctx.canvas.height / 1.3, out_ctx.canvas.height / 2);

        scale = canvases[0].parentElement.clientWidth / 6;

        requestAnimationFrame(redraw_all);
    }

    window.addEventListener('resize', layoutchanged);

    set_mode('zero'); // will not start animation on first call
    start_animation();

    recalculate_root_lines();
    update_G_description();
    k_changed();
    layoutchanged(); // calls redraw_all
</script>
</body>

<!--
TODO:
- op welk punt staat de muis?
- bode plot?
- tabel met np en polen
- tan(t) in K van Nyquist contour
- scale veranderen naar https://www.w3schools.com/jsref/canvas_scale.asp
-->
</html>