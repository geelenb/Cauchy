<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Visualizing closed loop poles</title>
    <style>
        body {
            margin: 0;
        }

        body > h1 {
            text-align: center;
            grid-area: top / left / 2 / right;
        }

        body > div.column {
            text-align: center;
            width: 23vw;
            float: left;
            margin: 0 1vw;
        }

        body > div#credits {
            clear: both;
            width: 100%;
        }

        canvas {
            box-shadow: grey 2px 2px 4px;
            border-radius: 6px;
        }

        canvas#bode_canvas {
            box-shadow: none;
        }

        table.equationtable {
            border-collapse: collapse;
        }

        table.equationtable td.counter {
            border-bottom: 1px solid black;
        }

        h1, h2, h3 {
            font-family: Futura, Helvetica, "Helvetica Neue", sans-serif;
        }

        p, div {
            font-family: Optima, sans-serif;
        }
    </style>

    <script src="math.min.js"></script>
    <script src="fraction.min.js"></script>
    <script src="complex.min.js"></script>
    <script src="polynomial.js"></script>
</head>
<body>
<h1>Visualizing closed loop poles</h1>

<div class="column">
    <h3>s-plane</h3>
    <canvas id="input_canvas" style="/* cursor: none */"></canvas>
    <p>
        This is the input screen, showing the poles and zeros of the function G(s).
        Add or remove zeros and poles to G by left- and right-clicking.
    </p>
    <div style="width: 11ch; display: inline-block; text-align: left;">
        K = 10<sup><span id="k_pow_span"></span></sup>
    </div>
    <br>
    <input id="krange" max="2" min="-2" step='.01' style="width: 250px; min-width: 50%; max-width: 100%;" type="range">
    <p id="G_equation"></p>
</div>

<div class="column">
    <h3>w-plane</h3>
    <canvas id="output_canvas"></canvas>
    <p>
        The blue point s is mapped to the w-plane by the function KG(s).
        Similarly, a contour is mapped to a plot.
        Note that you can scale this plot by modifying K.
    </p>
    <p>
        Use the following buttons to specify the interaction mode:
    </p>
    <p style="text-align: left">
        <input checked id="radiobutton_zero" name="interactiontype" onclick="set_mode('zero')" type="radio">
        <label for="radiobutton_zero">Orbit a zero</label><br>
        <input id="radiobutton_pole" name="interactiontype" onclick="set_mode('pole')" type="radio">
        <label for="radiobutton_pole">Orbit a pole</label><br>
        <input id="radiobutton_nyquist" name="interactiontype" onclick="set_mode('nyquist')" type="radio">
        <label for="radiobutton_nyquist">Nyquist contour</label><br>
        <input id="radiobutton_interactive" name="interactiontype" onclick="set_mode('interactive')"
               type="radio">
        <label for="radiobutton_interactive">Interactive</label><br>
    </p>
</div>
<div class="column">
    <h3>Bode Plot</h3>
    <canvas id="bode_canvas"></canvas>
</div>
<div class="column">
    <h3>Root locus</h3>
    <canvas id="rlocus_canvas"></canvas>
    <p>
        Shows the zeros of 1+KG(s) = 0 for every positive K.
        <br>
        <button onclick="RL.increase_K_range()">Enlarge range of Ks</button>
        <button onclick="RL.increase_K_resolution()">Increase resolution of Ks</button>
    </p>
</div>

<div id="credits" style="text-align: center">
    Made by Bram Geelen @ ESAT - STADIUS.
    <br>
    Source code at <a href="https://gitlab.esat.kuleuven.be/Bram.Geelen/cauchy" target="_blank">gitlab.esat.kuleuven.be/Bram.Geelen/cauchy</a>
    <br>
    Uses
    <a href="https://mathjs.org/" target="_blank">Math.js</a>,
    <a href="https://github.com/infusion/Fraction.js/" target="_blank">fraction.js</a>
    <a href="https://github.com/infusion/complex.js/" target="_blank">complex.js</a> and
    <a href="https://github.com/infusion/polynomial.js/" target="_blank">polynomial.js</a> .
</div>

<script>
    Polynomial.setField('C');

    let scale = 250;
    const sharpness = 3;
    const animation_speed = 2;
    const contour_length = 500;
    // let scale = 75;
    // const sharpness = 5;

    const in_ctx = document.getElementById('input_canvas').getContext('2d');
    const out_ctx = document.getElementById('output_canvas').getContext('2d');
    const rl_ctx = document.getElementById('rlocus_canvas').getContext('2d');
    const krange = document.getElementById('krange');
    const k_pow_span = document.getElementById('k_pow_span');

    let contour = [];

    class Output {
        constructor(ctx) {
            this.ctx = ctx;
            this.plot = [];
        }

        recalculate() {
            this.plot = contour.map(f);
        }

        draw_phasors() {
            const ctx = this.ctx;
            if (contour.length === 0) {
                return;
            }
            let sum_phase = 0;
            let r = 10 * sharpness;

            const s = headpoint(contour);
            ctx.save();

            ctx.strokeStyle = 'lightgrey';
            ctx.lineWidth = 1 * sharpness;
            const fs = headpoint(this.plot);

            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(fs.re * scale, -fs.im * scale);
            ctx.stroke();

            ctx.strokeStyle = 'darkgreen';

            zeros.forEach(z => {
                let phase = -s.sub(z).arg();

                ctx.beginPath();
                ctx.arc(0, 0, r, phase + sum_phase, sum_phase);
                ctx.stroke();

                sum_phase += phase;
                r += 5 * sharpness;
            });

            ctx.strokeStyle = 'red';
            poles.forEach(p => {
                let phase = s.sub(p).arg();

                ctx.beginPath();
                ctx.arc(0, 0, r, sum_phase, phase + sum_phase);
                ctx.stroke();

                sum_phase += phase;
                r += 5 * sharpness;
            });

            ctx.restore()
        };

        redraw() {
            const ctx = this.ctx;
            ctx.clearRect(-1000 * sharpness, -1000 * sharpness, 2000 * sharpness, 2000 * sharpness);
            add_axes(ctx);

            draw_points(ctx, this.plot);

            this.draw_phasors();
        }

    }

    OUT = new Output(out_ctx);

    let headpoint_index = 0;

    const zeros = [Complex(-2)];
    const poles = [Complex(-1, 1), Complex(-1, -1)];
    let K = 1;

    function f(s) {
        s = Complex(s);
        const counter = zeros.map(z => s.sub(z)).reduce(mul, Complex.ONE);
        const denominator = poles.map(p => s.sub(p)).reduce(mul, Complex.ONE);
        return counter.mul(K).div(denominator);
    }

    function add_drag(ctx) {
        ctx.canvas.addEventListener('mousedown', () => ctx.canvas.isdragging = false);

        ctx.canvas.addEventListener('mousemove', (event) => {
            if (event.buttons) {
                const dx = event.movementX * sharpness;
                const dy = event.movementY * sharpness;
                if (ctx === in_ctx || ctx === rl_ctx) {
                    in_ctx.translate(dx, dy);
                    rl_ctx.translate(dx, dy);
                    redraw_in();
                    RL.redraw();
                } else {
                    ctx.translate(dx, dy);
                }
                if (ctx === out_ctx) {
                    OUT.redraw();
                }

                ctx.canvas.isdragging = true;
            }
        });
    }

    add_drag(in_ctx);
    add_drag(out_ctx);
    add_drag(rl_ctx);

    function add_axes(ctx) {
        const axes_length = 10;

        ctx.save();
        ctx.font = '14px serif';

        ctx.strokeStyle = 'black';
        ctx.lineWidth = sharpness * 1;

        ctx.beginPath();
        ctx.moveTo(-1000 * sharpness * scale, 0);
        ctx.lineTo(+1000 * sharpness * scale, 0);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, -1000 * sharpness);
        ctx.lineTo(0, +1000 * sharpness);
        ctx.stroke();

        ctx.font = `${10 * sharpness}pt serif`;
        const x = -10 * sharpness;
        const y = 10 * sharpness;
        // labels
        for (let i = -axes_length; i <= axes_length; i++) {
            if (i === 0) {
                continue;
            }

            // x axis
            ctx.beginPath();
            ctx.moveTo(i * scale, 0);
            ctx.lineTo(i * scale, 6 * sharpness);
            ctx.stroke();

            ctx.textAlign = 'center';
            ctx.textBaseline = 'hanging';
            ctx.fillText(`${i}`, i * scale, y);

            // y axis
            ctx.beginPath();
            ctx.moveTo(0, i * scale);
            ctx.lineTo(-6 * sharpness, i * scale);
            ctx.stroke();

            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${i}j`, x, -i * scale);
        }

        ctx.textAlign = 'right';
        ctx.textBaseline = 'hanging';
        ctx.fillText('0', x, y);

        ctx.restore();
    }

    function headpoint(points) {
        if (mode === 'interactive') {
            return points[points.length - 1];
        } else {
            return points[headpoint_index % points.length];
        }
    }

    function draw_points(ctx, points) {
        if (points.length === 0) {
            return;
        }

        // if (window.mode === 'interactive') {
        //     const n = points.length;
        //     only plot last sqrt (length) items of points
        // points = points.slice(Math.floor(n - Math.sqrt(n)));
        // }

        points = points.map(s => [s.re * scale, -s.im * scale]);

        ctx.save();
        ctx.beginPath();
        ctx.moveTo(...(points[0]));

        ctx.strokeStyle = 'cyan';
        ctx.lineWidth = sharpness * 1;
        points.forEach(point => {
            ctx.lineTo(...point);
        });

        ctx.stroke();

        const point = points[(headpoint_index - 1 + points.length) % points.length];
        ctx.fillStyle = ctx.strokeStyle;
        ctx.beginPath();
        ctx.arc(point[0], point[1], 3 * sharpness, 0, math.tau);
        ctx.fill();

        ctx.restore();
    }

    function draw_poles(ctx) {
        const size = 3 * sharpness;
        ctx.save();
        ctx.strokeStyle = 'blue';
        ctx.lineWidth = sharpness * 1;
        poles.forEach(p => {
            ctx.beginPath();
            ctx.moveTo(p.re * scale - size, -(p.im * scale - size));
            ctx.lineTo(p.re * scale + size, -(p.im * scale + size));
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(p.re * scale - size, -(p.im * scale + size));
            ctx.lineTo(p.re * scale + size, -(p.im * scale - size));
            ctx.stroke();
        });

        ctx.restore();
    }

    function draw_zeros(ctx) {
        const r = 5 * sharpness;
        ctx.save();
        ctx.strokeStyle = 'blue';
        ctx.lineWidth = sharpness * 1;
        zeros.forEach(p => {
            ctx.beginPath();
            // ctx.moveTo(p.re * scale, -(p.im * scale));
            ctx.arc(p.re * scale, -(p.im * scale), r, 0, Math.PI * 2);
            ctx.stroke();
        });

        ctx.restore();
    }

    const mul = (a, b) => a.mul(b);
    const div = (a, b) => a.div(b);

    function redraw_in() {
        const draw_in_phasors = () => {
            if (contour.length === 0) {
                return;
            }

            const s = headpoint(contour);

            in_ctx.save();
            const r = 10 * sharpness;
            in_ctx.lineWidth = sharpness * 1;
            in_ctx.strokeStyle = 'lightgrey';
            poles.concat(zeros).forEach(c => {
                in_ctx.beginPath();
                in_ctx.moveTo(s.re * scale, -s.im * scale);
                in_ctx.lineTo(c.re * scale, -c.im * scale);
                in_ctx.stroke();
            });

            in_ctx.strokeStyle = 'red';
            in_ctx.lineWidth = sharpness * 1;
            poles.forEach(p => {
                in_ctx.beginPath();
                in_ctx.arc(p.re * scale, -p.im * scale, r, -s.sub(p).arg(), 0);
                in_ctx.stroke();
            });

            in_ctx.strokeStyle = 'darkgreen';
            in_ctx.lineWidth = sharpness * 1;
            zeros.forEach(z => {
                in_ctx.beginPath();
                in_ctx.arc(z.re * scale, -z.im * scale, r, -s.sub(z).arg(), 0);
                in_ctx.stroke();
            });

            in_ctx.restore()
        };


        in_ctx.clearRect(-1000 * sharpness, -1000 * sharpness, 2000 * sharpness, 2000 * sharpness);
        add_axes(in_ctx);

        draw_points(in_ctx, contour);

        draw_in_phasors();

        draw_poles(in_ctx);
        draw_zeros(in_ctx);
    }

    function complex_rand() {
        return Complex(math.random() - .5, math.random() - .5);
    }

    class RootLocus {
        constructor(ctx) {
            this.ctx = ctx;
            this.n_ks = 3000;
            this.max_exponent = 2;
            this.root_lines = [];
        }

        increase_K_resolution() {
            this.n_ks *= 2;
            this.recalculate_root_lines();
        }

        increase_K_range() {
            this.max_exponent += 1;
            this.recalculate_root_lines();
        }

        recalculate_root_lines() {
            // 1 + KP = 0
            // P = counter / denominator
            // denominator + K counter = 0
            console.log('calculating root lines');

            const counter = Polynomial.fromRoots(zeros);
            const denominator = Polynomial.fromRoots(poles);

            const ks = math.range(0, this.n_ks + 1).toArray()
                .map(i => Math.pow(10, (i / this.n_ks - .5) * 2 * this.max_exponent));

            const calculate_roots = (poly, est) => {
                let roots = [];
                poly = poly.monic();
                while (poly.coeff[0].abs() === 0) {
                    roots.push(Complex.ZERO);
                    poly = poly.div('x').monic();
                }

                if (est === undefined) {
                    est = Array(poly.degree()).fill().map(complex_rand)
                }

                poly.complexRoots(est).root.forEach(root => roots.push(root));

                return roots
            };

            const roots_per_K = [calculate_roots(counter.mul(ks[0]).add(denominator))];

            for (let i = 1; i < this.n_ks; i++) {
                let estimated_roots = roots_per_K[i - 1];
                roots_per_K.push(calculate_roots(
                    counter.mul(ks[i]).add(denominator),
                    estimated_roots
                ));
            }

            this.root_lines = roots_per_K[0].map(() => []);
            roots_per_K.forEach(roots =>
                roots.forEach((root, i) =>
                    this.root_lines[i].push(root)));

            this.redraw();
        }

        redraw() {
            const ctx = this.ctx;
            const draw_closed_loop_poles = () => {
                console.log('calculating closed loop poles for a single K...')
                // 1 + KP = 0
                // P = counter / denominator
                // denominator + K counter = 0

                const counter = Polynomial.fromRoots(zeros);
                const denominator = Polynomial.fromRoots(poles);

                const poly = counter.mul(K).add(denominator).monic();

                const est = Array(poly.degree()).fill(0).map(complex_rand);
                poly.complexRoots(est).root.forEach(root => {
                    let [x, y] = root.mul(scale).toVector();

                    ctx.save();
                    // ctx.strokeStyle = 'black';
                    ctx.lineWidth = sharpness * 2;

                    let d = .1 * scale;

                    ctx.beginPath();
                    ctx.moveTo(x - d, y);
                    ctx.lineTo(x + d, y);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(x, y - d);
                    ctx.lineTo(x, y + d);
                    ctx.stroke();

                    ctx.restore();
                });

            };
            const draw_root_lines = () => {
                ctx.save();
                ctx.strokeStyle = 'blue';
                ctx.lineWidth = sharpness * 2;

                this.root_lines.forEach(root_line => {
                    const points = root_line.map(s => s.mul(scale).toVector());

                    ctx.beginPath();
                    ctx.moveTo(...(points[0]));
                    points.forEach(point => {
                        ctx.lineTo(...point);
                    });

                    ctx.stroke();

                });
                ctx.restore();
            };


            ctx.clearRect(-1000 * sharpness, -1000 * sharpness, 2000 * sharpness, 2000 * sharpness);
            add_axes(ctx);

            draw_root_lines();
            draw_closed_loop_poles();

            draw_poles(ctx);
            draw_zeros(ctx);
        }
    }

    RL = new RootLocus(rl_ctx);

    /**
     * Round to n decimals after point
     * @param x
     * @param n decimals
     * @returns {number}
     */
    function round_n(x, n) {
        let p = Math.pow(10, n);
        return Math.round(x * p) / p
    }

    function coor_for_event(event, ctx) {
        const rect = ctx.canvas.getBoundingClientRect();
        const point_unscaled = (ctx
                .getTransform()
                .inverse()
                .transformPoint({
                    x: (event.clientX - rect.left) * sharpness,
                    y: (event.clientY - rect.top) * sharpness
                })
        );

        return Complex(
            point_unscaled.x,
            -point_unscaled.y
        ).div(scale)
    }

    function circle_around(p) {
        return math.range(0, math.tau, math.tau / contour_length).map(a => p.add({arg: -a, abs: 0.8})).toArray();
    }

    function nyquist_contour() {
        // const omegas = math.range(0, math.pi, .003).map(x => math.tan(x));
        const omegas = math.range(-2, 2, 4 / (contour_length / 2)).map(x => math.pow(10, x)).toArray();
        const omega_js = omegas.concat(...omegas.map(x => -1 / x)).map(o => Complex(0, o));
        return omega_js;
    }

    function start_animation() {
        if (window.mode === 'interactive') {
            return;
        }

        redraw_in();
        OUT.redraw();

        bode.redraw();

        headpoint_index += animation_speed;
        requestAnimationFrame(start_animation);
    }

    function set_mode(new_mode) {
        const was_not_animating = window.mode === 'interactive';

        window.mode = new_mode;

        if (new_mode === 'interactive') {
            contour = [];
        } else if (new_mode === 'zero') {
            contour = circle_around(zeros[math.randomInt(zeros.length)]);
        } else if (new_mode === 'pole') {
            contour = circle_around(poles[math.randomInt(poles.length)]);
        } else if (new_mode === 'nyquist') {
            contour = nyquist_contour();
        }

        OUT.recalculate();
        headpoint_index = 0;

        if (was_not_animating) {
            start_animation();
        }
    }

    in_ctx.canvas.addEventListener('mousemove', (event) => {
        if (window.mode === 'interactive') {
            const coor = coor_for_event(event, in_ctx);
            contour.push(coor);
            OUT.plot.push(f(coor));

            redraw_in();
            OUT.redraw();
        }
    });

    function pole_or_zero_clicked(event) {
        if (in_ctx.canvas.isdragging) {
            return;
        }

        let poles_or_zeros = event.type === 'contextmenu' ? poles : zeros;
        let clicked = coor_for_event(event, in_ctx);

        // remove poles_or_zeros that are close to click
        const pz_to_keep = poles_or_zeros.filter(z => clicked.sub(z).abs() > .2 && clicked.sub(z.conjugate()).abs() > .2);

        if (pz_to_keep.length !== poles_or_zeros.length) {
            // remove the poles_or_zeros in-place:
            poles_or_zeros.splice(0, poles_or_zeros.length, ...pz_to_keep);
        } else {
            // if no poles_or_zeros were removed: add one
            clicked = Complex(
                round_n(clicked.re, 1),
                round_n(clicked.im, 1)
            );
            poles_or_zeros.push(clicked);
            if (clicked.im !== 0) {
                poles_or_zeros.push(clicked.conjugate())
            }
        }

        plot = contour.map(f);
        RL.recalculate_root_lines();
        redraw_in();
        OUT.redraw();
        G_desc.update();
        event.preventDefault();
        bode.recalculate();
        bode.redraw();
    }

    in_ctx.canvas.addEventListener('click', pole_or_zero_clicked);
    in_ctx.canvas.addEventListener('contextmenu', pole_or_zero_clicked);

    class GDescription {
        constructor(elem_to_fill) {
            this.root = elem_to_fill;
        }

        update_K() {
            let K_str = K === 1 ? '' : String(round_n(K, 2));
            Array.from(document.getElementsByClassName('K_val')).forEach(elem => elem.innerText = K_str);
        }

        update() {
            const roots_to_html = roots => {
                if (roots.length == 0) {
                    return '1';
                }
                const complex_to_str = c => (c.re < 0 || (c.re == 0 && c.im < 0)) ? c.toString() : ('+' + c.toString());
                const complex_to_s_minus = c => Complex.ZERO.equals(c) ? 's' : '(s' + complex_to_str(Complex(0).sub(c)) + ')';
                const add_spacing = s => s.replaceAll('i', 'j').replaceAll('+', '&nbsp+&nbsp').replaceAll('-', '&nbsp-&nbsp');

                // TODO : powers for double roots?

                let html = roots.map(complex_to_s_minus).map(add_spacing).join('&nbsp;');

                if (roots.length == 1) {
                    html = html.substr(1, html.length - 2)
                }

                return html
            };

            const roots_to_html_poly = roots => {
                if (roots.length === 0) {
                    return '1';
                }
                const poly = Polynomial.fromRoots(roots);
                const coeffs = poly.monic().coeff;

                const s_pow = (pow) => pow === '0' ? '' : pow === '1' ? 's' : `s<sup>${pow}</sup>`;

                return Object.entries(coeffs).reverse().map(([pow, coeff], i) =>
                    `${coeff === 1 ? '' : round_n(coeff, 3)}${s_pow(pow)}`
                ).join('&nbsp;+&nbsp;').replaceAll('+&nbsp;-', '-&nbsp;').replaceAll('i', 'j');
            };

            let counter_roots = roots_to_html(zeros);
            let counter_polynomic = roots_to_html_poly(zeros);
            let denominator_roots = roots_to_html(poles);
            let denominator_polynomic = roots_to_html_poly(poles);

            this.root.innerHTML = [
                '<table class="equationtable"><tr>',
                '<td rowspan="2">KG(s)</td>',
                '<td rowspan="2" >=&nbsp; <span class="K_val"></span> </td>',
                `<td class="counter">&nbsp;${counter_roots}&nbsp;</td>`,
                '</tr>',
                '<tr>',
                `<td>&nbsp;${denominator_roots}&nbsp;</td>`,
                '</tr>',
                '<tr style="height: 2ch"></tr>',
                '<tr>',
                '<td rowspan="2"></td>',
                '<td rowspan="2">&nbsp;=&nbsp;<span class="K_val"></span> </td>',
                `<td class="counter">&nbsp;${counter_polynomic}&nbsp;</td>`,
                '</tr>',
                '<tr>',
                `<td>&nbsp;${denominator_polynomic}&nbsp;</td>`,
                '</tr>',
                '</table>'
            ].join('');
            this.update_K();
        }
    }

    G_desc = new GDescription(document.getElementById('G_equation'));

    class BodePlot {
        constructor(ctx) {
            this.tick_length = 10;

            this.ctx = ctx;

            this.min_omega_pow = -3;
            this.max_omega_pow = 3;
            const n_x = 100;

            this.omega_pows = math.range(
                this.min_omega_pow,
                this.max_omega_pow,
                (this.max_omega_pow - this.min_omega_pow) / n_x
            ).toArray().concat([this.max_omega_pow]);

            this.tick_pows = math.range(this.min_omega_pow, this.max_omega_pow + 1, 1).toArray();
            this.omega_js = this.omega_pows.map(x => Complex(0, math.pow(10, x)));

            const superchar = i => i == 1 ? '' : i < 4 ? String.fromCodePoint(176 + i) : String.fromCodePoint(8304 + math.abs(i));
            const pow_to_str = o => o == 0 ? '1' : (o < 0 ? '0.1' : '10') + superchar(math.abs(o));
            this.tick_labels = this.tick_pows.map(pow_to_str);

            this.recalculate();
        }

        complex_db(c) {
            return 20 * math.log(c.abs())
        }

        complex_deg(c) {
            return 180 * c.arg() / math.PI;
        }

        recalculate() {
            const ctx = this.ctx;

            const plot = this.omega_js.map(f);
            const dbs = plot.map(this.complex_db);
            const phases = plot.map(this.complex_deg);
            // TODO: unwrap phases?

            const min_phase = math.min(...phases, 180);
            const max_phase = math.max(...phases, 180);
            const min_db = math.min(...dbs, 1);
            const max_db = math.max(...dbs, 1);

            this.h = ctx.canvas.height;
            this.w = ctx.canvas.width;

            this.xmin = .12 * this.w;
            this.xmax = .95 * this.w;

            this.mag_top = ctx.lineWidth;
            this.mag_bottom = .47 * this.h;

            this.phase_top = .53 * this.h;
            this.phase_bottom = this.h - ctx.lineWidth;

            const omega_pow_to_x_scale = (this.xmax - this.xmin) / (this.max_omega_pow - this.min_omega_pow);
            this.omega_pow_to_x = (o) => this.xmin + (o - this.min_omega_pow) * omega_pow_to_x_scale;

            this.x_ticks = this.tick_pows.map(this.omega_pow_to_x);
            this.x_data = this.omega_pows.map(this.omega_pow_to_x);

            this.db_to_y = (sb) => this.mag_bottom - .05 * (this.mag_bottom - this.mag_top) -
                (sb - min_db) * .9 * (this.mag_bottom - this.mag_top) / (max_db - min_db);

            this.deg_to_y = (deg) => this.phase_bottom - .05 * (this.phase_bottom - this.phase_top) -
                (deg - min_phase) * .9 * (this.phase_bottom - this.phase_top) / (max_phase - min_phase);

            this.db_data_y = dbs.map(this.db_to_y);
            const db_ticks = [
                ...math.range(0, max_db, 20).toArray(),
                ...math.range(0, min_db, -20).toArray().slice(1)
            ];
            this.db_ticks_y = db_ticks.map(this.db_to_y);
            this.db_ticks_labels = db_ticks.map(db => `${db}dB`);

            // yticks deg
            const deg_ticks = [
                ...math.range(0, max_phase * 1.05, 45).toArray(),
                ...math.range(0, min_phase * 1.01, -45).toArray().slice(1)
            ];
            this.deg_ticks_ys = deg_ticks.map(this.deg_to_y);
            this.deg_ticks_labels = deg_ticks.map(deg => `${deg}Â°`);

            this.y_phase_data = phases.map(this.deg_to_y);
        }

        draw_rectangles() {
            const ctx = this.ctx;
            ctx.rect(this.xmin, this.mag_top, this.xmax - this.xmin, this.mag_bottom - this.mag_top);
            ctx.stroke();

            ctx.rect(this.xmin, this.phase_top, this.xmax - this.xmin, this.phase_bottom - this.phase_top);
            ctx.stroke();
        };

        draw_x_ticks() {
            const ctx = this.ctx;
            ctx.font = `${10 * sharpness}pt serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            this.x_ticks.forEach((x, i) => {
                ctx.moveTo(x, this.mag_bottom);
                ctx.lineTo(x, this.mag_bottom + this.tick_length);

                ctx.fillText(this.tick_labels[i], x, this.h / 2);

                ctx.moveTo(x, this.phase_top);
                ctx.lineTo(x, this.phase_top - this.tick_length);
            });
            ctx.stroke();
        }

        draw_data(xs, ys) {
            const ctx = this.ctx;
            ctx.moveTo(xs[0], ys[0]);
            ys.forEach((y, i) => ctx.lineTo(xs[i], y));
            ctx.stroke();
        }

        draw_yticks(ys, labels) {
            const ctx = this.ctx;
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';

            ys.forEach((y, i) => {
                ctx.moveTo(this.xmin, y);
                ctx.lineTo(this.xmin - this.tick_length, y);

                ctx.fillText(labels[i], this.xmin - this.tick_length - 5, y);
            });
            ctx.stroke();
        }

        add_nyquist_helplines() {
            const ctx = this.ctx;
            ctx.save();

            const s = headpoint(contour);
            const p = f(Complex(0, s.abs()));
            const x = this.omega_pow_to_x(math.log10(s.abs() + .0001));
            const deg_y = this.deg_to_y(this.complex_deg(p));
            const amp_y = this.db_to_y(this.complex_db(p));

            ctx.strokeStyle = 'lightgray';

            ctx.beginPath();
            ctx.moveTo(x, this.mag_top);
            ctx.lineTo(x, this.mag_bottom);

            ctx.moveTo(x, this.phase_top);
            ctx.lineTo(x, this.phase_bottom);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(this.xmin, deg_y);
            ctx.lineTo(x, deg_y);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(this.xmin, amp_y);
            ctx.lineTo(x, amp_y);
            ctx.stroke();

            ctx.restore();
        }

        add_margin_lines() {
            // TODO: margin lines?
        }

        redraw() {
            const ctx = this.ctx;

            ctx.clearRect(-1000 * sharpness, -1000 * sharpness, 2000 * sharpness, 2000 * sharpness);

            ctx.lineWidth = sharpness * 1;

            ctx.save();

            ctx.beginPath();
            ctx.strokeStyle = 'black';

            this.draw_rectangles();
            this.draw_x_ticks();

            this.draw_yticks(this.db_ticks_y, this.db_ticks_labels);
            this.draw_data(this.x_data, this.db_data_y);

            this.draw_yticks(this.deg_ticks_ys, this.deg_ticks_labels);
            this.draw_data(this.x_data, this.y_phase_data);

            if (mode === 'nyquist') {
                this.add_nyquist_helplines();
            } else {
                this.add_margin_lines();
            }

            ctx.restore()
        }
    }

    bode = new BodePlot(document.getElementById('bode_canvas').getContext('2d'));

    function k_changed() {
        K = Math.pow(10, krange.value);
        k_pow_span.innerText = krange.value;

        OUT.recalculate();
        OUT.redraw();
        RL.redraw();
        G_desc.update_K();
        bode.recalculate();
        bode.redraw();
    }

    krange.addEventListener('input', k_changed);

    function layoutchanged() {
        let canvases = document.querySelectorAll('canvas');
        canvases.forEach(canvas => {
            let w = canvas.parentElement.clientWidth;
            canvas.width = w * sharpness;
            canvas.height = w * sharpness;
            canvas.style.width = w + 'px';
            canvas.style.height = w + 'px';
        });

        in_ctx.translate(out_ctx.canvas.height / 1.3, out_ctx.canvas.height / 2);
        out_ctx.translate(out_ctx.canvas.height / 2, out_ctx.canvas.height / 2);
        rl_ctx.translate(out_ctx.canvas.height / 1.3, out_ctx.canvas.height / 2);

        // scale = canvases[0].parentElement.clientWidth / 6;

        redraw_in();
        OUT.redraw();
        RL.redraw();

        bode.recalculate();
        bode.redraw();
    }

    window.addEventListener('resize', layoutchanged);

    set_mode('zero'); // will not start animation on first call
    // set_mode('nyquist'); // will not start animation on first call
    start_animation();

    RL.recalculate_root_lines();
    G_desc.update();
    k_changed();
    layoutchanged(); // calls redraw_all
</script>
</body>

<!--
TODO:
- op welk punt staat de muis?
- tabel met np en polen
-->
</html>