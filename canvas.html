<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        body {
        }

        canvas {
            margin: 12px;
            box-shadow: black 0px 0 12px;
            border-radius: 12px;
        }
    </style>

    <script src="math.min.js"></script>
    <script src="complex.min.js"></script>
</head>
<body>

    <div>
        <button onclick="set_mode('zero')">Oscilleer rond een nulpunt</button>
        <button onclick="set_mode('pole')">Oscilleer rond een pool</button>
        <button onclick="set_mode('nyquist')">Nyquistplot</button>
        <button onclick="set_mode('interactive')">Interactief</button>
    </div>

    <div id="container">
        <canvas id="input_canvas" height="500px" width="500px"></canvas>
        <canvas id="output_canvas" height="500px" width="500px"></canvas>
    </div>
    <script>

        const scale = 75;

        const in_ctx = document.getElementById('input_canvas').getContext('2d');
        const out_ctx = document.getElementById('output_canvas').getContext('2d');

        in_ctx.translate(out_ctx.canvas.height / 1.3, out_ctx.canvas.height / 2);
        out_ctx.translate(out_ctx.canvas.height / 2, out_ctx.canvas.height / 2);

        let wand_points = [];
        let wand_points_transformed = [];
        let points_start_index = 30;

        let zeros = [Complex(-2)];
        let poles = [Complex(-3, -2), Complex(-3, 2)];
        let K = 1;

        function add_drag(ctx) {
            ctx.canvas.addEventListener('mousedown', (event) => {
                ctx.canvas.isdragging = true;
            });

            const enddrag = () => ctx.canvas.isdragging = false;

            ctx.canvas.addEventListener('mouseup', enddrag);
            ctx.canvas.addEventListener('mouseout', enddrag);

            ctx.canvas.addEventListener('mousemove', (event) => {
                if (ctx.canvas.isdragging) {
                    ctx.translate(event.movementX, event.movementY);
                    requestAnimationFrame(redraw_all)
                }
            });
        }

        function add_zoom(ctx) {
            ctx.canvas.addEventListener('wheel', (event) => {
                console.log('wheel')
                // event.preventDefault();

            }, false);
        }

        function add_axes(ctx) {
            ctx.font = '14px serif';

            ctx.strokestyle = 'black';
            ctx.lineWidth = 1;

            ctx.beginPath();
            ctx.moveTo(-1000 * scale, 0);
            ctx.lineTo(+1000 * scale, 0);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(0, -1000);
            ctx.lineTo(0, +1000);
            ctx.stroke();

            // labels
            for (let i = -100; i <= 100; i++) {
                if (i === 0) {
                    continue;
                }

                // x axis
                ctx.beginPath();
                ctx.moveTo(i * scale, 0);
                ctx.lineTo(i * scale, 6);
                ctx.stroke();

                ctx.textAlign = 'center';
                ctx.textBaseline = 'hanging';
                ctx.fillText(`${i}`, i * scale, 10);

                // y axis
                ctx.beginPath();
                ctx.moveTo(0, i * scale);
                ctx.lineTo(-6, i * scale);
                ctx.stroke();

                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                ctx.fillText(`${i}j`, -10, -i * scale);
            }

            ctx.textAlign = 'right';
            ctx.textBaseline = 'hanging';
            ctx.fillText('0', -10, 10)
        }

        function draw_points(ctx, points) {
            // debugger;
            const l = points.length;

            if (l === 0) {
                return;
            }

            points = points.map(s => [s.re * scale, -s.im * scale]);

            if (window.mode === 'interactive') {
                points = last_sqrt_items_of_list(points);
            } else {
                const i = points_start_index % points.length;
                points = points.slice(i).concat(points.slice(0, i)).slice(Math.floor(points.length * .2));
            }

            ctx.save();
            ctx.beginPath();
            ctx.moveTo(...(points[0]));

            points.forEach(point => {
                ctx.strokeStyle = 'cyan';
                ctx.lineTo(...point);
            });

            ctx.stroke();

            const point = points[points.length - 1];
            ctx.beginPath();
            ctx.arc(point[0], point[1], 3, 0, 2 * Math.PI);
            // ctx.arc(-1*scale, 0, 30, 0, 2 * Math.PI);
            // console.log(point[0] / scal);
            ctx.fillStyle = ctx.strokeStyle;
            ctx.fill();

            ctx.restore();
        }

        function draw_in_phasors() {
            if (wand_points.length === 0) {
                return;
            }
            const s = wand_points[wand_points.length - 1];
            in_ctx.save();
            const r = 10;
            in_ctx.strokeStyle = 'lightgrey';
            poles.concat(zeros).forEach(c => {
                in_ctx.beginPath();
                in_ctx.moveTo(s.re * scale, -s.im * scale);
                in_ctx.lineTo(c.re * scale, -c.im * scale);
                in_ctx.stroke();
            });

            in_ctx.strokeStyle = 'red';
            poles.forEach(p => {
                in_ctx.beginPath();
                in_ctx.arc(p.re * scale, -p.im * scale, r, -s.sub(p).arg(), 0);
                in_ctx.stroke();
            });

            in_ctx.strokeStyle = 'darkgreen';
            zeros.forEach(p => {
                in_ctx.beginPath();
                in_ctx.arc(p.re * scale, -p.im * scale, r, -s.sub(p).arg(), 0);
                in_ctx.stroke();
            });

            in_ctx.restore()
        }

        function draw_out_phasors() {
            if (wand_points.length === 0) {
                return;
            }
            let sum_phase = 0;
            let r = 10;

            const s = wand_points[wand_points.length - 1];
            out_ctx.save();

            out_ctx.strokeStyle = 'lightgrey';
            const fs = wand_points_transformed[wand_points_transformed.length-1]
            out_ctx.beginPath();
            out_ctx.moveTo(0, 0);
            out_ctx.lineTo(fs.re * scale, -fs.im * scale);
            out_ctx.stroke();

            out_ctx.strokeStyle = 'darkgreen';

            zeros.forEach(z => {
                out_ctx.beginPath();
                let phase = -s.sub(z).arg();
                out_ctx.arc(0, 0, r, phase + sum_phase, sum_phase);
                sum_phase += phase;
                r += 5;
                out_ctx.stroke();
            });

            out_ctx.strokeStyle = 'red';
            poles.forEach(p => {
                out_ctx.beginPath();
                let phase = s.sub(p).arg();
                out_ctx.arc(0, 0, r, sum_phase, phase + sum_phase);
                sum_phase += phase;
                r += 5;
                out_ctx.stroke();
            });

            out_ctx.restore()
        }

        function draw_poles() {
            const size = 3;
            in_ctx.save();
            in_ctx.strokeStyle = 'blue';
            poles.forEach(p => {
                in_ctx.beginPath();
                in_ctx.moveTo(p.re * scale - size, -(p.im * scale - size));
                in_ctx.lineTo(p.re * scale + size, -(p.im * scale + size));
                in_ctx.stroke();
                in_ctx.beginPath();
                in_ctx.moveTo(p.re * scale - size, -(p.im * scale + size));
                in_ctx.lineTo(p.re * scale + size, -(p.im * scale - size));
                in_ctx.stroke();
            });

            in_ctx.restore();
        }

        function draw_zeros() {
            const r = 5;
            in_ctx.save();
            in_ctx.strokeStyle = 'blue';
            zeros.forEach(p => {
                in_ctx.beginPath();
                // in_ctx.moveTo(p.re * scale, -(p.im * scale));
                in_ctx.arc(p.re * scale, -(p.im * scale), r, 0, Math.PI * 2 );
                in_ctx.stroke();
            });

            in_ctx.restore();

        }

        const mul = (a, b) => a.mul(b);

        function make_function() {
            return s => {
                s = Complex(s);
                const counter = zeros.map(z => s.sub(z)).reduce(mul, Complex.ONE);
                const denominator = poles.map(p => s.sub(p)).reduce(mul, Complex.ONE);
                return counter.mul(K).div(denominator);
            }
        }


        function last_sqrt_items_of_list(l) {
            const n = l.length;
            return l.slice(Math.floor(n - Math.sqrt(n)));
        }

        function redraw_in() {
            in_ctx.clearRect(-1000, -1000, 2000, 2000);
            add_axes(in_ctx);
            // debugger;
            draw_points(in_ctx, wand_points);

            draw_in_phasors();

            draw_poles();
            draw_zeros();
        }

        function redraw_out() {
            out_ctx.clearRect(-1000, -1000, 2000, 2000);
            add_axes(out_ctx);
            // debugger;

            draw_points(out_ctx, wand_points_transformed);

            draw_out_phasors();
        }

        function redraw_all() {
            redraw_in();
            redraw_out();
        }

        function coor_for_event(event, ctx) {
            const rect = ctx.canvas.getBoundingClientRect();
            const point_unscaled = (ctx
                    .getTransform()
                    .inverse()
                    .transformPoint({
                        x: event.clientX - rect.left,
                        y: event.clientY - rect.top
                    })
            );
            return Complex(
                point_unscaled.x / scale,
                -point_unscaled.y / scale
            )
        }

        function circle_around(p) {
            const n = 1000;
            return [...Array(n).keys()].reverse().map(v => p.add({arg: ((v / n) * 2 * Math.PI), abs: 0.5}));
        }

        function nyquist_contour() {
            const n = 100;
            const omega_js = [...Array(n).keys()].map(o => Math.exp(o-(n/2))).map(o => Complex.I.mul(o));
            return omega_js.concat([Complex.INFINITY], omega_js.map(oj => oj.conjugate()).reverse(), [Complex.ZERO]);
        }

        function start_animation() {
            if (window.mode === 'interactive') {
                return;
            }
            redraw_all();

            points_start_index += 1;
            setTimeout(start_animation, 5);
        }

        function set_mode(new_mode) {
            window.mode = new_mode;

            if (new_mode === 'interactive') {
                wand_points = [];
                wand_points_transformed = [];
            } else if (new_mode === 'zero') {
                wand_points = circle_around(zeros[0]);
                wand_points_transformed = wand_points.map(make_function());
            } else if (new_mode === 'pole') {
                wand_points = circle_around(poles[0]);
                wand_points_transformed = wand_points.map(make_function());
            } else if (new_mode === 'nyquist') {
                wand_points = nyquist_contour();
                wand_points_transformed = wand_points.map(make_function());
            }
            requestAnimationFrame(redraw_all);

            start_animation();
        }

        [in_ctx, out_ctx].forEach(ctx => {
            add_drag(ctx);
        });

        mode = 'interactive';
        requestAnimationFrame(redraw_all);

        in_ctx.canvas.addEventListener('mousemove', (event) => {
            if (mode === 'interactive') {
                const coor = coor_for_event(event, in_ctx);
                wand_points.push(coor);
                wand_points_transformed.push(make_function()(coor));

                // if (Math.random() < .8) {
                //     wand_points = wand_points.slice(1);
                //     wand_points_transformed = wand_points_transformed.slice(1);
                // }
            }
            requestAnimationFrame(redraw_all);
        });

        in_ctx.canvas.addEventListener('click', (event) => {
            const clicked = Complex(coor_for_event(event, in_ctx));

            const l = zeros.length;
            zeros = zeros.filter(z => clicked.sub(z).abs() > .2);
            if (zeros.length === l){
                zeros.push(clicked);
            }

            wand_points_transformed = wand_points.map(make_function())
            requestAnimationFrame(redraw_all);
            event.preventDefault();
        });

        in_ctx.canvas.addEventListener('contextmenu', (event) => {
            const clicked = Complex(coor_for_event(event, in_ctx));

            const l = poles.length;
            poles = poles.filter(z => clicked.sub(z).abs() > .2);
            if (poles.length === l){
                poles.push(clicked);
            }

            wand_points_transformed = wand_points.map(make_function())
            requestAnimationFrame(redraw_all);
            event.preventDefault();
        }, false);

    </script>
</body>
</html>