<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>

    <style>
        body {
            background: black;
        }

        canvas {
            background: white;
        }
    </style>

    <script src="math.min.js"></script>
    <script src="complex.min.js"></script>
</head>
<body>
    <canvas id="input_canvas" height="500px" width="500px"></canvas>
    <canvas id="output_canvas" height="500px" width="500px"></canvas>

    <script>
        const inf = 1_000_000_000;
        const scale = 100;

        const in_ctx = document.getElementById('input_canvas').getContext('2d');
        const out_ctx = document.getElementById('output_canvas').getContext('2d');

        in_ctx.translate(3 * scale, 2.5 * scale);
        out_ctx.translate(2.5 * scale, 2.5 * scale);

        let wand_points = [];
        let wand_points_transformed = [];

        let zeros = [Complex(-1)];
        let poles = [Complex(-2, -2), Complex(-2, 2)];
        let K = 1;

        function add_drag(ctx) {
            ctx.canvas.addEventListener('mousedown', (event) => {
                ctx.canvas.isdragging = true;
            });

            const enddrag = () => ctx.canvas.isdragging = false;

            ctx.canvas.addEventListener('mouseup', enddrag);
            ctx.canvas.addEventListener('mouseout', enddrag);

            ctx.canvas.addEventListener('mousemove', (event) => {
                if (ctx.canvas.isdragging) {
                    ctx.translate(event.movementX, event.movementY);
                    requestAnimationFrame(redraw_all)
                }
            });
        }

        function add_zoom(ctx) {
            ctx.canvas.addEventListener('wheel', (event) => {
                // ctx.canvas.isdragging = true;
                // debugger;
                console.log('wheel')
                // event.preventDefault();

            }, false);
        }

        function add_axes(ctx) {
            ctx.font = '14px serif';

            ctx.strokestyle = 'black';
            ctx.lineWidth = 1;

            ctx.beginPath();
            ctx.moveTo(-1_000 * scale, 0);
            ctx.lineTo(+1_000 * scale, 0);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(0, -inf);
            ctx.lineTo(0, +inf);
            ctx.stroke();

            // labels
            for (let i = -100; i <= 100; i++) {
                if (i === 0) {
                    continue;
                }

                // x axis
                ctx.beginPath();
                ctx.moveTo(i * scale, 0);
                ctx.lineTo(i * scale, 6);
                ctx.stroke();

                ctx.textAlign = 'center';
                ctx.textBaseline = 'hanging';
                ctx.fillText(`${i}`, i * scale, 10);

                // y axis
                ctx.beginPath();
                ctx.moveTo(0, i * scale);
                ctx.lineTo(-6, i * scale);
                ctx.stroke();

                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                ctx.fillText(`${i}j`, -10, -i * scale);
            }

            ctx.textAlign = 'right';
            ctx.textBaseline = 'hanging';
            ctx.fillText('0', -10, 10)
        }

        function redraw(ctx) {
            ctx.clearRect(-inf, -inf, inf*2, inf*2);
            add_axes(ctx);
        }

        function draw_points(ctx, points) {
            // debugger;
            const l = points.length;

            if (l === 0) {
                return;
            }

            // points = points.slice(Math.floor(l - Math.sqrt(l)));

            points = points.map(s => [s.re * scale, -s.im * scale])

            ctx.save();
            ctx.beginPath();
            ctx.moveTo(...(points[0]));

            points.forEach(point => {
                ctx.strokeStyle = 'cyan';
                ctx.lineTo(...point);
            });

            ctx.stroke();
            ctx.restore();
        }


        function draw_in_phasors() {
            if (wand_points.length === 0) {
                return;
            }
            const s = wand_points[wand_points.length - 1];
            in_ctx.save();
            const r = 10;
            in_ctx.strokeStyle = 'lightgrey';
            poles.concat(zeros).forEach(c => {
                in_ctx.beginPath();
                in_ctx.moveTo(s.re * scale, -s.im * scale);
                in_ctx.lineTo(c.re * scale, -c.im * scale);
                in_ctx.stroke();
            });

            in_ctx.strokeStyle = 'red';
            poles.forEach(p => {
                in_ctx.beginPath();
                in_ctx.arc(p.re * scale, -p.im * scale, r, -s.sub(p).arg(), 0);
                in_ctx.stroke();
            });

            in_ctx.strokeStyle = 'darkgreen';
            zeros.forEach(p => {
                in_ctx.beginPath();
                in_ctx.arc(p.re * scale, -p.im * scale, r, -s.sub(p).arg(), 0);
                in_ctx.stroke();
            });

            in_ctx.restore()
        }

        function draw_out_phasors() {

        }

        function draw_poles() {
            const size = 3;
            in_ctx.save();
            poles.forEach(p => {
                in_ctx.beginPath();
                in_ctx.moveTo(p.re * scale - size, -(p.im * scale - size));
                in_ctx.lineTo(p.re * scale + size, -(p.im * scale + size));
                in_ctx.stroke();
                in_ctx.beginPath();
                in_ctx.moveTo(p.re * scale - size, -(p.im * scale + size));
                in_ctx.lineTo(p.re * scale + size, -(p.im * scale - size));
                in_ctx.stroke();
            });

            in_ctx.restore();
        }

        function draw_zeros() {
            const r = 5;
            in_ctx.save();
            zeros.forEach(p => {
                in_ctx.beginPath();
                // in_ctx.moveTo(p.re * scale, -(p.im * scale));
                in_ctx.arc(p.re * scale, -(p.im * scale), r, 0, Math.PI * 2 );
                in_ctx.stroke();
            });

            in_ctx.restore();

        }

        const mul = (a, b) => a.mul(b);

        function make_function() {
            return s => {
                s = Complex(s);
                const counter = zeros.map(z => s.sub(z)).reduce(mul, Complex.ONE);
                const denominator = poles.map(p => s.sub(p)).reduce(mul, Complex.ONE);
                return counter.mul(K).div(denominator);
            }
        }

        let f = make_function();

        function last_sqrt_items_of_list(l) {
            const n = l.length;
            return l.slice(Math.floor(n - Math.sqrt(n)));
        }

        function redraw_in() {
            in_ctx.clearRect(-inf, -inf, inf*2, inf*2);
            add_axes(in_ctx);
            const l = wand_points.length;
            draw_points(in_ctx, last_sqrt_items_of_list(wand_points));

            draw_in_phasors();

            draw_poles();
            draw_zeros();
        }

        function redraw_out() {
            out_ctx.clearRect(-inf, -inf, inf*2, inf*2);
            add_axes(out_ctx);

            draw_points(out_ctx, last_sqrt_items_of_list(wand_points_transformed));

            draw_out_phasors();
        }

        function redraw_all() {
            redraw_in();
            redraw_out();
        }

        function coor_for_event(event, ctx) {
            const rect = ctx.canvas.getBoundingClientRect();
            const point_unscaled = (ctx
                    .getTransform()
                    .inverse()
                    .transformPoint({
                        x: event.clientX - rect.left,
                        y: event.clientY - rect.top
                    })
            );
            return Complex(
                point_unscaled.x / scale,
                -point_unscaled.y / scale
            )
        }

        function distances(a, l) {
            return l.map(b => a.sub(b).abs())
        }

        [in_ctx, out_ctx].forEach(ctx => {
            add_drag(ctx);
        });

        requestAnimationFrame(redraw_all);

        in_ctx.canvas.addEventListener('mousemove', (event) => {
            const coor = coor_for_event(event, in_ctx);
            wand_points.push(coor);
            wand_points_transformed.push(f(coor));

            requestAnimationFrame(redraw_all);
        });

        in_ctx.canvas.addEventListener('click', (event) => {
            const clicked = Complex(coor_for_event(event, in_ctx));

            const l = zeros.length;
            zeros = zeros.filter(z => clicked.sub(z).abs() > .2);
            if (zeros.length === l){
                zeros.push(clicked);
            }

            redraw_in();
        });

        in_ctx.canvas.addEventListener('contextmenu', (event) => {
            const clicked = Complex(coor_for_event(event, in_ctx));
            const l = poles.length;
            poles = poles.filter(z => clicked.sub(z).abs() > .2);
            if (poles.length === l){
                poles.push(clicked);
            }
            redraw_in();
            event.preventDefault();
        }, false);

    </script>
</body>
</html>